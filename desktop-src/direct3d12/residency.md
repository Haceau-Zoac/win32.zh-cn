---
title: 驻留
description: 由 GPU 情况下，对象被视为可驻留时对其进行访问。
ms.assetid: 956F80D7-EEC8-4D88-B251-EE325614F31E
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 96ca17ada8e9e464880b202e9752ce72a5d8005f
ms.sourcegitcommit: 1fbe7572f20938331e9c9bd6cccd098fa1c6054d
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/27/2019
ms.locfileid: "66224194"
---
# <a name="residency"></a>驻留

一个对象被视为*常驻*时由 GPU 可访问。

-   [驻留预算](#residency-budget)
-   [堆资源](#heap-resources)
-   [驻留优先级](#residency-priorities)
    -   [默认优先级算法](#default-priority-algorithm)
-   [编程驻留管理](#programming-residency-management)
-   [相关的主题](#related-topics)

## <a name="residency-budget"></a>驻留预算

Gpu 尚不支持分页错误，因此 GPU 无法访问的同时应用程序必须将数据提交到物理内存。 此过程被称为"使内容常驻"，并且必须为完成的物理系统内存和物理离散的视频内存。 D3D12，大多数 API 对象将封装一定量的 GPU 可访问的内存。 该 GPU 可访问的内存是 API 对象的创建过程中进行常驻和逐出 API 对象析构。

可供进程的物理内存量称为视频内存预算。 预算可以显著节省成本作为后台进程唤醒和睡眠;并且，当用户切换到另一个应用程序时显著波动。 应用程序可以预算更改时得到通知，并轮询当前预算和当前已使用的内存量。 如果应用程序不会保持其预算内，该进程将间歇性地冻结，以允许运行其他应用程序，和/或创建 Api 将返回失败。 [ **IDXGIAdapter3** ](https://msdn.microsoft.com/library/windows/desktop/dn933221)接口提供了与此功能，特别是相关方法[ **QueryVideoMemoryInfo** ](https://msdn.microsoft.com/library/windows/desktop/dn933223)并[ **RegisterVideoMemoryBudgetChangeNotificationEvent**](https://msdn.microsoft.com/library/windows/desktop/dn933231)。

应用程序，建议保留用于表示它们不能转而无需内存量。 理想情况下，用户指定"低"图形设置，或甚至降低，是此类保留的正确值。 设置保留不会不断为应用程序提供更高版本的预算不是通常情况下，它将接收。 相反，保留项信息可帮助快速最小化的影响较大内存压力的情况下操作系统内核。 即使保留不保证可供该应用程序时应用程序不是前台应用程序。

## <a name="heap-resources"></a>堆资源

虽然许多 API 对象封装一些 GPU 可访问的内存堆和资源都将是最重要的方式应用程序中使用和管理物理内存。 堆是最低的级别单元来管理物理内存，因此最好具有一定熟悉它们驻留的属性。

-   堆不能成为部分常驻，但解决方法存在使用预留的资源。
-   堆时应列入特定池的一部分。 UMA 适配器具有一个池，而离散适配器具有两个池。 该内核可以将离散的适配器上某些堆从视频内存转移到系统内存，则返回 true 时，它会因此仅作为极端的最后一招。 应用程序不应依赖于内核，超出预算行为，并应改为关注好预算管理。
-   可以从驻留，允许其内容会分页到磁盘中逐出堆。 但是，堆析构是一种更可靠的技术，以释放驻留在所有适配器体系结构。 在适配器上其中*theMaxGPUVirtualAddressBitsPerProcess*字段[ **D3D12\_功能\_数据\_GPU\_虚拟\_地址\_支持**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support)预算大小接近[**逐出**](/windows/desktop/api/D3D12/nf-d3d12-id3d12device-evict)可靠地不会回收驻留。
-   堆创建可能会很慢;但它非常适合后台线程处理。 建议堆上创建后台线程，以避免干扰呈现线程。 D3D12，在多个线程可以安全地调用同时创建例程。

D3D12 带来更多灵活性和正交性到其资源模型要使应用程序的更多选项。 有三个高级类型的资源中 D3D12： 提交、 放置，和保留。

-   已提交的资源在同一时间创建资源和一个堆。 堆是隐式和不能直接访问。 堆是适当地调整大小以找到在堆中的整个资源。
-   放置的资源允许的资源时堆中的非零偏移量的位置。 通常必须为 64 KB; 与对齐的偏移量但在这两个方向上存在一些例外情况。 MSAA 资源需要 4 MB 偏移量的对齐方式，可用于小纹理 4KB 偏移量的对齐方式。 不能重定位或重新映射到另一个堆中直接调用放置的资源但是，它们启用堆之间的资源数据的简单重定位。 不同堆中创建新的放置的资源，并将资源数据复制之后, 新资源描述符将需要为新的资源数据位置。
-   当适配器支持平铺的资源层 1 或更高版本时，保留的资源才可用。 如果可用，它们提供最先进的驻留可用，则管理方法但不是所有适配器当前都支持它们。 它们使重新资源映射而无需重新生成资源描述符、 部分 mip 级别驻留和稀疏纹理方案，等等。并非所有资源类型都支持甚至保留的资源可用时，因此完全通用的基于页面的驻留 manager 尚不可行。

## <a name="residency-priorities"></a>驻留优先级

Windows 10 创意者更新使开发人员来影响该堆和资源将是首选保持驻留时内存不足的情况需要一些资源来将其降级。 这可帮助开发人员通过利用运行时不能从 API 使用情况推断出的知识来创建更好的执行应用程序。 其预期，开发人员将成为更舒适和具有指定优先级，因为他们从使用已提交的资源添加到保留和平铺的资源转换功能。

将应用这些优先级必须是再简单不过管理两个动态内存预算，手动降级和升级资源 bettween 它们，因为已应用程序可以执行此操作。 因此，驻留优先级 API 的设计是 coursely 粒度合理的默认优先级分配给每个堆或为其创建的资源。 有关详细信息，请参阅[ **ID3D12Device1::SetResidencyPriority** ](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority)并[ **D3D12\_驻留\_优先级**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority)枚举。

具有优先级，开发人员应为：

-   引发几个出色的堆，以更好地减轻这些堆更快地或不是其自然访问模式可能要求更频繁地降级的经验丰富的性能影响的优先级。 此方法应可供从图形 Api，如 Direct3D 11 或 OpenGL，移植应用程序用户具有资源管理模型是明显不同于 Direct3D 12。
-   重写的应用程序自身 bucketization 方案中，固定，根据访问频率的程序员的知识或动态; 使用的几乎所有堆优先级固定的方案会比动态管理，但可会降低，需要使用编程人员干预的开发过程中使用模式的变化更为简单。 此方法应可供使用 Direct3D 12 样式资源管理的需求，如那些使用驻留库 （尤其是动态方案） 构建的应用程序。

### <a name="default-priority-algorithm"></a>默认优先级算法

应用程序不能指定为尝试管理默认优先级算法，而第一个 understaning 任何堆的有用优先级。 这是因为到争用同一内存其他按优先顺序排列堆的分配到堆的特定优先级的值派生自其相对优先级。

选择用于生成默认优先级是进行分类到两个存储桶的堆的策略，优先列出 （同时将更高优先级） 堆，假定写经常由 GPU 在不是堆。

高优先级存储桶包含堆，并使用它们作为标识的标记创建的资源的呈现器目标、 深度模具缓冲区或无序访问视图 (Uav)。 这些分配了优先级值处开始的范围中**D3D12\_驻留\_优先级\_高**; 若要进一步确定这些堆和资源、 优先级的最低 16 位之间的优先级设置为堆或除以 10 MB （饱和到 0xFFFF 对于非常大的堆） 的资源的大小。 此额外的优先顺序倾向于更大的堆和资源。

低优先级存储桶包含所有其他堆和资源，它们将分配的优先级值为**D3D12\_驻留\_优先级\_正常**。 在这些堆之间没有进一步优先顺序和尝试的资源。

## <a name="programming-residency-management"></a>编程驻留管理

简单的应用程序可以通过仅仅遇到内存不足故障之前创建已提交的资源来获取。 如果失败，应用程序可能会破坏其他提交的资源或 API 对象，以启用进一步的资源创建成功。 但是，强烈建议甚至简单的应用程序监视的负预算更改和销毁未使用的 API 对象大约一次一个帧。

尝试针对适配器体系结构或并入驻留优先级进行优化时，将会增加驻留管理设计的复杂性。 它们分别预算和管理两个离散的内存池将比管理仅有一个更复杂并且 asigning 宽刻度上固定优先级可以成为维护负担的使用模式演变。 溢出到系统内存的纹理将添加更复杂的环境，如在系统内存中错误的资源可能严重影响帧速率。 并没有简单的功能来帮助确定将受益于更高的 GPU 带宽或容忍较低的 GPU 带宽的资源。

更加复杂的设计将查询当前适配器的功能。 此信息现已推出[ **D3D12\_功能\_数据\_GPU\_虚拟\_地址\_支持**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support)，[ **D3D12\_功能\_数据\_体系结构**](/windows/desktop/api/D3D12/ns-d3d12-d3d12_feature_data_architecture)， [ **D3D12\_平铺\_资源\_层**](/windows/desktop/api/D3D12/ne-d3d12-d3d12_tiled_resources_tier)，并[ **D3D12\_资源\_堆\_层**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier)。

多个部分的应用程序很可能最终会使用不同的技术。 例如，某些大型纹理和已执行很少的代码路径可能会使用已提交的资源，虽然很多纹理而言可能使用流式处理的属性指定和使用的通用资源放置的技术。

## <a name="related-topics"></a>相关主题

<dl> <dt>

[**ID3D12Heap**](/windows/desktop/api/D3D12/nn-d3d12-id3d12heap)
</dt> <dt>

[内存管理](memory-management.md)
</dt> </dl>

 

 





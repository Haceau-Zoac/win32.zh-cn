---
title: 内存别名和数据继承
description: 放置和保留的资源可能别名堆中的物理内存。 当堆有设置了共享的标志或使用别名资源时已完全定义内存布局，放置资源启用比保留资源的更多数据继承方案。
ms.assetid: 53C5804B-0F81-41AF-83D2-A96DCDFDC94A
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e1f9abc85e925973e82ec1a1a39bd2a3aed05a03
ms.sourcegitcommit: 1fbe7572f20938331e9c9bd6cccd098fa1c6054d
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/27/2019
ms.locfileid: "66224044"
---
# <a name="memory-aliasing-and-data-inheritance"></a>内存别名和数据继承

放置和保留的资源可能别名堆中的物理内存。 当堆有设置了共享的标志或使用别名资源时已完全定义内存布局，放置资源启用比保留资源的更多数据继承方案。

-   [别名](#memory-aliasing-and-data-inheritance)
-   [数据继承](#data-inheritance)
-   [相关的主题](#related-topics)

## <a name="aliasing"></a>别名

别名屏障必须颁发之间共享相同的物理内存，即使数据继承不所需的两个资源的使用情况。 至少，简单的使用情况模型必须指明此类操作中涉及的目标资源。 请参阅[ **CreatePlacedResource** ](/windows/desktop/api/D3D12/nf-d3d12-id3d12device-createplacedresource)有关更多详细信息和高级使用情况模型。

访问的资源后，该资源与共享的物理内存的任何资源将成为无效，除非数据继承允许发生。 读取的无效的资源导致未定义的资源内容。 写入请求到无效的资源也会导致未定义的资源的内容，除非两个条件发生：

-   资源不具有任一 D3D12\_资源\_标志\_允许\_呈现\_目标或 D3D12\_资源\_标志\_允许\_深度\_模具。
-   写入操作已复制或对整个子资源或磁贴的清除操作。 磁贴初始化功能仅适用于资源与 64KB\_磁贴\_UNDEFINED\_SWIZZLE 和 64 KB\_磁贴\_标准\_SWIZZLE。

重叠失效的作用域为较小粒度，当布局纹素数据的位置上的位置上提供的信息和资源时某些转换屏障状态。 但是，失效，无法执行任何小于资源对齐粒度。

缓冲区对齐粒度为 64 KB，且更大的对齐方式粒度优先。 这很重要时考虑到 4 KB 的纹理相同，因为多个 4 KB 纹理可以驻留在 64KB 区域而不相互重叠。 但是，不能与任何这些 4KB 纹理结合使用缓冲区别名相同的 64 KB 区域。 应用程序不能可靠地保持访问到缓冲区相交 4KB 纹理从 Gpu，允许对 swizzle 4KB 纹理数据中未定义的模式的 64KB 区域内。

64KB\_磁贴\_UNDEFINED\_SWIZZLE、 64KB\_磁贴\_标准\_SWIZZLE 和行\_主要纹理布局通知应用程序的重叠的对齐方式粒度已变得无效。 例如：应用程序可以使用 2 个数组切片，单个 mip 创建 2D 呈现器目标纹理数组，级别和 64 KB 的倍数\_磁贴\_UNDEFINED\_SWIZZLE 布局。 假定应用程序能够了解每个数组切片占用 100 64KB 磁贴。 应用程序可以放弃使用数组切片 0，并重复使用的内存约 6 MB 的缓冲区、 约 6 MB 纹理具有未定义的布局，等等。更进一步，假定应用程序不再需要数组段 1 的第一个磁贴。 然后，应用程序还可以查找的 64 KB 缓冲区，直到再次需要数组段 1 的第一个磁贴呈现。 应用程序必须清除操作的完整的磁贴，或将复制，以便重新再次使用纹理数组的第一个磁贴。

但是，即使纹理与定义的布局仍必须有问题的情况。 纹理资源大小可能显著不同于哪些应用程序可以计算本身，因为某些适配器体系结构分配额外内存用于纹理以降低在常见的呈现方案过程中的有效带宽。 该额外的内存区域到任何失效导致要成为失效的整个资源。 请参阅[ **GetResourceAllocationInfo** ](/windows/desktop/api/D3D12/nf-d3d12-id3d12device-getresourceallocationinfo)的更多详细信息。

## <a name="data-inheritance"></a>数据继承

放置资源启用纹理，即使使用未定义的内存布局的大多数数据继承。 应用程序可模拟共享已提交的资源的功能，通过共享的堆中相同的偏移量位置处找到具有相同的资源属性的这两个纹理数据继承。 整个资源说明必须完全相同，包括优化清除值和类型的资源创建方法 （放置或保留）。 但是，这两个资源可能具有不同的初始转换屏障状态。

保留的资源启用每个磁贴数据继承;但对于资源转换屏障状态通常存在限制。

若要继承的数据，这两个资源必须是兼容的资源转换屏障状态：

-   缓冲区，同时访问纹理，并跨适配器纹理资源转换状态并不重要，所有状态都为"兼容"。
-   对于保留的纹理，而无需以前的属性或其他每个磁贴数据继承通过 64KB\_磁贴\_UNDEFINED\_SWIZZLE 或 64KB\_磁贴\_标准\_SWIZZLE，包括该磁贴资源转换屏障状态必须处于通用状态。
-   对于所有其他纹理，其中资源说明完全匹配，每对相应的子资源转换屏障状态必须：
    -   在常见的状态。
    -   状态在它们具有相同的 GPU 写标志时，为等于。

如果 GPU 支持标准 swizzle，可能会有相同的内存的别名和继承它们之间的数据缓冲区和标准 swizzle 纹理。 应用程序可以处理从缓冲区表示形式的纹素，因为标准 swizzle 模式描述了纹素在内存中的布局方式。 CPU 可见 swizzle 模式相当于在缓冲区中看到的 GPU 可见 swizzle 模式。

## <a name="related-topics"></a>相关主题

<dl> <dt>

[子中堆分配](suballocation-within-heaps.md)
</dt> </dl>

 

 





---
title: 描述符堆概述
description: 描述符堆包含不是一部分的管道状态对象 (PSO)，如着色器资源视图 (SRVs)、 无序访问视图 (Uav)、 常量缓冲区视图 (CBVs) 和取样器的许多对象类型。
ms.assetid: 14561E77-44E0-4A58-8456-F40D59ECA175
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bb04405aaa98659ebe8e33807256de3fb727688a
ms.sourcegitcommit: 1fbe7572f20938331e9c9bd6cccd098fa1c6054d
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/27/2019
ms.locfileid: "66224134"
---
# <a name="descriptor-heaps-overview"></a>描述符堆概述

描述符堆包含不是一部分的管道状态对象 (PSO)，如着色器资源视图 (SRVs)、 无序访问视图 (Uav)、 常量缓冲区视图 (CBVs) 和取样器的许多对象类型。

-   [描述符堆的用途](#the-purpose-of-descriptor-heaps)
-   [同步](#synchronization)
-   [Binding](#binding)
-   [切换堆](#switching-heaps)
-   [捆绑包](#bundles)
-   [管理](#management)
-   [相关的主题](#related-topics)

## <a name="the-purpose-of-descriptor-heaps"></a>描述符堆的用途

描述符堆的主要目的是以包含所需的存储对象的描述符规范作为呈现尽可能的窗口的大类型对于该着色器引用的内存分配的大容量 (理想情况下的呈现整个帧或详细介绍）。 如果应用程序正在切换的纹理管道会看到快速从 API，需要通过描述符堆来定义所需状态的每个组动态的描述符表中的空间。 应用程序可以选择重用定义，如果在另一个对象中将再次使用的资源，例如，或只是将分配的堆空间按顺序如切换各种对象类型。

描述符堆还允许每个单独管理描述符存储各个软件组件。

所有堆都可以看到 CPU。 应用程序还可以请求哪些 CPU 访问属性描述符堆应 （如果有） – 编写组合、 写回，依次类推。 应用可以创建任意多个描述符堆根据需要包含所需的所有属性。 应用始终可以选择创建描述符堆的仅仅是用于过渡的大小，不受约束的目的，将复制到描述符堆，用于呈现在必要时。

有在相同的描述符堆中可能出现的一些限制。 CBV、 UAV 和 SRV 条目可以位于相同的描述符堆。 但是，取样器条目不能共享堆 CBV、 UAV 或 SRV 条目。 通常情况下，有两个组的描述符堆，一个用于公共资源，第二个用于取样器。

使用描述符堆的 Direct3D 12 反映了大多数 GPU 硬件的作用，这是堆，要求仅在描述符中的实时描述符或只是，如果使用这些堆必需的寻址位数更少。 Direct3D 12 中确实需要使用描述符堆，没有将描述符放在内存中的任意位置的选项。

描述符堆只能是由 CPU 立即编辑，没有选项来编辑由 GPU 描述符堆。

## <a name="synchronization"></a>同步

之前、 期间和之后记录引用它的命令列表，可以更改描述符堆内容。 但是，描述符时，无法将更改提交要执行的命令列表可能会引用该位置中，因为这可能调用一个争用条件。

## <a name="binding"></a>绑定

最多一个 CBV/SRV/UAV 合堆，并且可以在任何一次绑定一个采样器堆。 这些堆之间的这两个图形共享，并且计算管道 （其 Pso 中所述）。

## <a name="switching-heaps"></a>切换堆

它是可以接受的应用程序若要切换同一命令列表中或在使用不同的堆[ **SetDescriptorHeaps** ](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps)并[**重置**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-reset) Api。 在某些硬件上，这可以是代价高昂的操作，需要 GPU 停滞，将刷新依赖于当前绑定的描述符堆的所有工作。 因此，如果描述符堆必须进行更改，应用程序应尝试执行此操作相对较轻的 GPU 工作负荷时，可能限制更改为命令列表的开头。

## <a name="bundles"></a>捆绑包

与捆绑包只能有一次调用[ **SetDescriptorHeaps** ](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps)方法和描述符堆设置必须完全匹配的调用绑定的命令列表。 如果绑定不会更改描述符表，它不需要设置描述符堆。

有关不能用于捆绑包的 API 调用的列表，请参阅[创建和记录命令将列出和捆绑包](recording-command-lists-and-bundles.md)。

## <a name="management"></a>Management

若要呈现的所有对象在场景中，将需要多个描述符，并且有可后接一些不同的管理策略。

最基本的策略是填充中的下一个绘图调用的要求的所有描述符堆的新区域。 因此，只需发出前上命令列表的绘图调用，描述符表指针将设置为刚刚填充的表的开始。 优点是，则无需对其中任何特定的描述符是堆中的记录。

此策略的缺点是重复的，尤其是重复的在呈现非常相似的场景时，可能是重复的大量描述符堆中的描述符，该描述符堆空间即将用完快速。 对于那些在 GPU 上呈现堆单独描述符和这些记录的 CPU，可能会有必要，以避免冲突。 或者可以使用二次分配系统。

此外，基本系统无法进一步优化小心使用重叠的描述符表从一个绘图调用到下一步，以便添加需要的只是新的描述符。

比基本更有效的策略是预先填充具有所需的对象 （或材料） 的描述符堆描述符的已知场景的部分。 这里的思路是，它只是用来在绘制时，设置描述符表如预先填充描述符堆。

预填充策略的一种变体是要被视为一个大数组，包含在固定的已知位置所需的所有描述符描述符堆。 然后绘图调用需要仅接收一组常量是中的描述符的需要使用的数组的索引。

进一步优化是为了确保根常量和根描述符包含那些最频繁更改，而不是位置描述符堆中的常量。 对于大多数硬件这是一种处理常量有效途径。

在实践中图形引擎可能会在不同情况下，使用不同的策略，并将合并每个策略以满足特定的绘制要求元素。

## <a name="related-topics"></a>相关主题

<dl> <dt>

[描述符堆](descriptor-heaps.md)
</dt> </dl>

 

 





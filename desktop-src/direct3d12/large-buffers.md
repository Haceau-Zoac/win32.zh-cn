---
title: 缓冲区中的二次分配
description: 缓冲区具有 D3D12 所需的所有功能，可供应用程序将大量瞬态数据从 CPU 传输到 GPU。 本节介绍使用和管理资源及缓冲区的四种常见场景。
ms.assetid: 359E377A-8E16-4BB5-9055-09617335AB57
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d64944cb11507b8dc437d075938fad419f333433
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/16/2019
ms.locfileid: "71005760"
---
# <a name="suballocation-within-buffers"></a>缓冲区中的二次分配

缓冲区具有 D3D12 所需的所有功能，可供应用程序将大量瞬态数据从 CPU 传输到 GPU。 本节介绍使用和管理资源及缓冲区的四种常见场景。

与 D3D11 类似，相较于 D3D11 中的动态/暂存资源，D3D12 中的应用程序在分配 D3D12 中的缓冲区时仍然需要声明内存的使用情况，但在 D3D12 中，开发人员对内存使用有更大的灵活性和更严格的控制。 通过二次分配，缓冲区可具有低级内存管理所需的所有功能。

## <a name="in-this-section"></a>本节内容



| 主题                                                                                        | 描述                                                                                                                                                                                                                                                                                                                                                                                                             |
|----------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [上传不同类型的资源](uploading-resources.md)<br/>                 | 演示如何使用一个缓冲区将常量缓冲区数据和顶点缓冲区数据上传到 GPU，以及如何在缓冲区中正确地二次分配和放置数据。 使用单个缓冲区可提高内存使用灵活性，并为应用程序提供更严格的内存使用控制。 还将演示 D3D11 和 D3D12 模型在上传不同类型资源方面的差异。<br/> |
| [通过缓冲区上传纹理数据](upload-and-readback-of-texture-data.md)<br/> | 上传 2D 或 3D 纹理数据与上传 1D 数据类似，但应用程序需要更密切地关注与行间距相关的数据对齐情况。 可以从图形管道的多个部分正交和同时使用缓冲区，缓冲区非常灵活。 <br/>                                                                                                                       |
| [通过缓冲区读回数据](readback-data-using-heaps.md)<br/>                    | 从 GPU 读取数据（例如捕获屏幕截图）需要使用 Readback 堆。 <br/>                                                                                                                                                                                                                                                                                                     |
| [基于围栏的资源管理](fence-based-resource-management.md)<br/>            | 演示如何利用通过围栏跟踪 GPU 进度来管理资源数据的生存期。 可有效地重复使用内存，用围栏来仔细管理内存中可用空间的可用性，例如针对“上传”堆环形缓冲区实现。 <br/>                                                                                                                                                     |



 

## <a name="related-topics"></a>相关主题

<dl> <dt>

[内存管理](memory-management.md)
</dt> </dl>

 

 






---
title: Windows 编码习惯
description: 如果你刚刚接触 Windows 编程，那你就会在第一次看见 Windows 程序的时候感到困惑。
ms.topic: article
ms.date: 15/02/2021
---

# Windows 编码习惯

果你刚刚接触 Windows 编程，那你就会在第一次看见 Windows 程序的时候感到困惑。整个代码充斥着奇怪的类型定义，比如 **DWORD\_PTR** 以及 **LPRECT**，并且变量的命名也是 *hWnd* 和 *pwsz* 之类（它叫做匈牙利命名法）。掏出些时间来学习 Windows 编码习惯是非常值得的。

绝大多数 Windows API 都是由函数或组件对象模型（COM）构成的。拥有 C++ 类的 Windows API 非常少。（一个值得注意的例外是 GDI+，一个 2D 图形 API。）

## 类型定义

Windows 头文件包括非常多的类型定义。许多都是在 WinDef.h 中定义的。这里有一些经常用到的定义。

### 整数类型



| 数据类型      | 大小  | 有无符号？ |
| ------------- | ----- | ---------- |
| **BYTE**      | 8 位  | 无符号     |
| **DWORD**     | 32 位 | 无符号     |
| **INT32**     | 32 位 | 有符号     |
| **INT64**     | 64 位 | 有符号     |
| **LONG**      | 32 位 | 有符号     |
| **LONGLONG**  | 64 位 | 有符号     |
| **UINT32**    | 32 位 | 无符号     |
| **UINT64**    | 64 位 | 无符号     |
| **ULONG**     | 32 位 | 无符号     |
| **ULONGLONG** | 64 位 | 无符号     |
| **WORD**      | 16 位 | 无符号     |



 

可以看到，这里有一定数量的冗余定义。有些冗余仅仅是 Windows API 的历史遗留。列表中的类型都有着固定的大小，在 32 位和 64 位应用程序中都是相同的。比如，**DWORD** 类型一直是 32 位大小。

### 布尔类型

在布尔上下文中会使用到一个名为 **BOOL** 的整数类型定义。WinDef.h 头文件还同时为其定义了两个与 **BOOL** 一起使用的值。


```C++
#define FALSE    0 
#define TRUE     1
```



虽然这里定义了 **TRUE**，但大多数返回 **BOOL** 的函数还是可以返回任何非 0 值表示真值。你应该这样编写程序：


```C++
// 正确。
BOOL result = SomeFunctionThatReturnsBoolean();
if (result) 
{ 
    ...
}
```

并且不要这样：


```C++
// 错误！
if (result == TRUE) 
{
    ... 
}
```



你应该认识到 **BOOL** 是一个整数类型，它和 C++ 的 **bool** 类型是完全不同的。

### 指针类型

Windows 定义了非常多的指针类型来表示 *指向 X*。他们通常都会有一个 *P-* 或 *LP-* 前缀。例如，**LPRECT** 就是一个指向一个用来描述矩形的 [**RECT**](/previous-versions//dd162897(v=vs.85)) 结构体的指针。下面的变量声明是相等的。


```C++
RECT*  rect;  // 指向 RECT 结构体的指针。
LPRECT rect;  // 相同
PRECT  rect;  // 这个也相同。
```



历史上，*P* 标志着”指针“，*LP* 标志着”长指针“。长指针（也叫*远指针*）是在 16 位 Windows 中使用的，在某处的内存地址超出了当前段的时候就会派上用场。*LP* 前缀被用来简单地在 16 位和 32 位程序中移植。现在他们没有区别──指针就是指针。

### 指针精度类型

这些数据类型都是的指针一样的大小──32 位程序有 32 位大小，64 位程序是 64 位宽度。大小在编译时就已确定。在 32 位程序运行在 64 位 Windows 上时，这些数据依旧保持 4 字节大小。（64 位程序不能在 32 位 Windows 上运行，所以反转过来的情况是不存在的）

-   **DWORD\_PTR**
-   **INT\_PTR**
-   **LONG\_PTR**
-   **ULONG\_PTR**
-   **UINT\_PTR**

这些类型在需要可以转换为指针类型的整数的地方使用。还会用来定义指针运算的变量，定义循环计数器，循环计数器在内存缓冲区中的整个字节范围内进行迭代。一般情况下，它更多地出现在需要在 64 位 Windows 中从 32 位扩大到 64 位的地方。

## 匈牙利命名法

*匈牙利命名法*是为变量命名加上前缀，使其表示更多信息的命名法。（这个命名法的作者是查尔斯·西蒙尼，是个匈牙利人，匈牙利命名法也因此得名）。

在最开始的形式中，匈牙利命名法给予变量*语义*信息，告诉你预定用法。例如，*i* 表示下标（index），*cb* 表示字节大小（count of bytes），*rw* 和 *col* 分别表示行数（row）和列数（column）。这些前缀设计避免了在错误的上下文中意外地使用了变量。例如，如果你看到了 `rwPosition +  cbTable` 表达式，你就能知道他的意思是行数加大小，几乎可以肯定是出现了 bug。

一个更常见的匈牙利命名法的形式是给予变量*类型*信息──比如，*dw* 代表 **DWORD**，*w* 代表 **WORD**。

如果你在网上搜索“匈牙利命名法”，你会找到非常多对于匈牙利命名法的好坏争论。一些程序员厌恶匈牙利命名法。还有一些认为它很有帮助。不管怎样，MSDN 上有许多使用匈牙利命名法的例子，但你不需要记住前缀然后再去理解代码。

## 下一步

[使用字符串](working-with-strings.md)

 

 